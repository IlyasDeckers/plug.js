{"name":"Plug.js","tagline":"Plug JS is a lightweight JavaScript dependency injection and object life-cycle management library","body":"# Plug.js\r\n\r\nPlug.js is a lightweight JavaScript dependency injection and object life-cycle management library. The purpose of Plug.js is to provide a flexible way to connect modules and share data between them without requiring a hard dependency on a framework or a steep learning curve.\r\n\r\nWith no dependencies on third-party libraries, Plug.js weighs in at just 5kb (minified).\r\n\r\nPlug.js' dependency registration uses a familiar RequireJS/AngularJS style signature making it quick and easy for developers with all different levels of experience to get up and running.\r\n\r\n\r\n**Table of Contents**\r\n\r\n- [Plug.js](#plugjs)\r\n\t- [The Facts](#the-facts)\r\n\t- [Why use Plug.js?](#why-use-plugjs)\r\n\t- [Get Plugging](#get-plugging)\r\n\t\t- [Usage](#usage)\r\n\t\t\t- [Singleton](#singleton)\r\n\t\t\t- [Transient](#transient)\r\n\t\t- [Variables](#variables)\r\n\t\t\t- [Inject by Value](#inject-by-value)\r\n\t\t\t- [Inject by Reference](#inject-by-reference)\r\n\t- [Resolving Registrations](#resolving-registrations)\r\n\t- [Dependencies](#dependencies)\r\n\t- [Prototypes](#prototypes)\r\n\t- [Factories](#factories)\r\n\t- [Browser Compatibility](#browser-compatibility)\r\n\r\n\r\n## The Facts\r\n\r\n* Plug.js **is not** a module loader (*RequireJS*)\r\n* Plug.js **is** a dependency injector\r\n* Plug.js **is not** a full framework (*AngularJS*)\r\n* Plug.js **is** an object lifecycle manager\r\n\r\n\r\n## Why use Plug.js?\r\n\r\nPlug.js is designed to encourage less dependencies on frameworks that are often packed with more features than required for most project situations. It's also designed to be simple for even the most novice developer. Finally, Plug.js is designed to be flexible - to fit around your project, not make your project fit around it. This decoupling allows developers to easily upgrade and/or swap technologies without redesigning the entire front-end architecture.  \r\n\r\n\r\n## Get Plugging\r\n\r\nFirst, download the Plug.js file or Plug.min.js (*recommended*) file and include it in your page either in the `<head>` section or just before the closing tag of the `<body>` section.\r\n\r\nTo use Plug.js it's as simple as registering modules and variables. By default Plug.js provides two type of lifecycle factories (*explained below*): **singleton** and **transient**. A singleton registration will ensure only a single instance of the registered module is ever resolved, while a transient registration will return a new instance of the module each time it is resolved.\r\n\r\n### Usage\r\n\r\n```javascript\r\nplug.singleton(\"moduleName\", [ injectionSignature ], [ prototypes ])\r\n```\r\n**or**\r\n```javascript\r\nplug.transient(\"moduleName\", [ injectionSignature ], [ prototypes ])\r\n```\r\n\r\n| Argument | Type | Example | Required |\r\n| -------- | ---- | ------- | -------: |\r\n| moduleName | String | `\"resourceModule\"` | true |\r\n| injectionSignature | Array | `[ function () { ... } ]` **or** `[ \"dependency\", function(dependency) { ... } ]` | true |\r\n| prototypes | String **or** Array[String] | [ \"animalPrototype\", \"carPrototype\" ] | false |\r\n\r\n\r\n#### Singleton\r\n```javascript\r\nplug.singleton(\"singletonModule\", [ function() {\r\n\r\n    function doSomething() {\r\n        alert(\"Did Something!\");\r\n    }\r\n\r\n    this.doSomething = doSomething;\r\n\r\n} ]);\r\n```\r\n\r\n#### Transient\r\n```javascript\r\nplug.transient(\"transientModule\", [ function() {\r\n\r\n    function doSomething() {\r\n        alert(\"Did Something!\");\r\n    }\r\n\r\n    this.doSomething = doSomething;\r\n\r\n} ]);\r\n```\r\n\r\n**Note**: The `oMod` module is injected (as a singleton) into each plug instance. The `oMod` module allows you to perform various operations on objects such as cloning and extending.\r\n\r\n\r\n### Variables\r\n\r\nPlug.js allows you to inject variables into the module scope. There are two types of injection available for variables: inject by **value**, and inject by **reference**.\r\n\r\nInjecting a variable by value will inform Plug.js to create a clone of the object before it is injected into a module (*only applicable to reference types eg. Object, Array, Function*).\r\n\r\nInjecting a variable by reference will inform Plug.js to treat the object normally and inject the reference to the variable into the module (*JavaScript's default behaviour for reference types*).\r\n\r\n**Note**: A locally scoped reference to the `window` and the `document` objects are injected into modules by default. You can use these locally scoped variables by simply declaring them as a dependency to your module.\r\n\r\n#### Inject by Value\r\n\r\n`plug.value(\"variableName\", value, deepClone)`\r\n\r\n| Argument | Type | Example | Required |\r\n| -------- | ---- | ------- | -------: |\r\n| variableName | String | `\"customResolver\"` | true |\r\n| value | Object | {} | true |\r\n| deepClone | Boolean | true | false |\r\n\r\n```javascript\r\n\r\n(function() {\r\n\r\n    /* Simple value types */\r\n    var foo = \"Hello World\",\r\n        bar = 7;\r\n\r\n    /* Complex reference type */\r\n    var complexType = {\r\n        foo: [\r\n            { a: new Date(), b: \"test 1\" },\r\n            { a: new Date(), b: \"test 2\" },\r\n            { a: new Date(), c: \"test 3\" }\r\n        ],\r\n        bar: {\r\n            a: function() {\r\n                alert(\"foo bar\");\r\n            },\r\n            b: {\r\n                a: function() {\r\n                    alert(\"another foo bar\");\r\n                }\r\n            }\r\n        }    \r\n    };\r\n\r\n    /* Inject the values */\r\n    plug.value(\"foo\", foo);\r\n    plug.value(\"bar\", bar);\r\n\r\n    /* alternatively, use method chaining: plug.value(...).value(...).reference(...); */\r\n\r\n    /* Deep clone */\r\n    plug.value(\"complexType\", complexType, true);\r\n    /* When complexType is resolved it will be a new instance in each resolution. In other words complexType1.foo !== complexType2.foo */\r\n    /* Modifying values on complexType1 has no effect on complexType2 */\r\n})();\r\n\r\n```\r\n\r\n#### Inject by Reference\r\n\r\n`plug.reference(\"variableName\", value, deepClone)`\r\n\r\n| Argument | Type | Example | Required |\r\n| -------- | ---- | ------- | -------: |\r\n| variableName | String | `\"customResolver\"` | true |\r\n| value | Object | {} | true |\r\n\r\n```javascript\r\n\r\n(function() {\r\n\r\n    /* Simple value types */\r\n    var foo = \"Hello World\",\r\n        bar = 7;\r\n\r\n    /* Complex reference type */\r\n    var complexType = {\r\n        foo: [\r\n            { a: new Date(), b: \"test 1\" },\r\n            { a: new Date(), b: \"test 2\" },\r\n            { a: new Date(), c: \"test 3\" }\r\n        ],\r\n        bar: {\r\n            a: function() {\r\n                alert(\"foo bar\");\r\n            },\r\n            b: {\r\n                a: function() {\r\n                    alert(\"another foo bar\");\r\n                }\r\n            }\r\n        }    \r\n    };\r\n\r\n    /* Inject the values */\r\n    plug.reference(\"foo\", foo);\r\n    plug.reference(\"bar\", bar);\r\n\r\n    /* alternatively, use method chaining: plug.value(...).value(...).reference(...); */\r\n\r\n    /* Deep clone */\r\n    plug.reference(\"complexType\", complexType, true);\r\n    /* When complexType is resolved it will be the same instance in each resolution. In other words complexType1.foo === complexType2.foo */\r\n    /* Modifying values on complexType1 changes values on complexType2 because they are the same object */\r\n})();\r\n\r\n```\r\n\r\n## Resolving Registrations\r\nPlug.js uses a single method to resolve registered objects outside the context of a module constructor.\r\n\r\n```javascript\r\nvar fooBar = plug.resolve(\"moduleOrVariableName\")\r\n```\r\n**or**\r\n```javascript\r\nvar fooBar = plug.resolve([ \"module1\", \"module2\", \"value1\", \"module3\" ])\r\n```\r\n\r\nUsing the array method will return an object with each resolution as a property of the object, whereas the default string method will return the single resolution.\r\n\r\n\r\n## Dependencies\r\nWhen registering a module you can define any other modules or registered variables that should be injected into your module.\r\n\r\n**Note**: *Dependencies must be registered* **before** *being referenced in another module.*\r\n\r\n```javascript\r\nplug.singleton(\"module1\", [ function() {\r\n\r\n    function saySomething(message) {\r\n        alert(message);\r\n    }\r\n\r\n    this.saySomething = saySomething;\r\n\r\n} ]);\r\n\r\nplug.singleton(\"module2\", [ \"module1\", function(module1) {\r\n\r\n    function saySomethingOnOtherModule(message) {\r\n        module1.saySomething(message);\r\n    }\r\n\r\n    this.saySomethingOnOtherModule = saySomethingOnOtherModule;\r\n\r\n} ]);\r\n\r\nvar module2 = plug.resolve(\"module2\");\r\nmodule2.saySomethingOnOtherModule(\"Hello World!\");\r\n```\r\n\r\n## Prototypes\r\nPlug.js' prototype management allows you to automate your modules inheritance. By adding prototypes to Plug.js you can assign any number of prototypes to your module when registering it. When the module is resolved, it's prototype is extended with the prototypes you assign to it.\r\n\r\nYou can register a prototype on Plug.js using the `from` function.\r\n\r\n`plug.from(\"prototypeName\", prototype)`\r\n\r\n| Argument | Type | Example | Required |\r\n| -------- | ---- | ------- | -------: |\r\n| prototypeName | String | `\"prototypeName\"` | true |\r\n| prototype | Object | {} | true |\r\n\r\nTo visualize how this works consider this example:\r\n\r\nlet's assume you have a module called `smartWatch`. A smart watch can be considered both a **watch** and a **smart device**. A watch has behaviors such as *displaying the time*, *start stopwatch* and *stop stopwatch*. A smart device has behaviors such as *connecting to Bluetooth*, *connecting to Wi-Fi*, *GPS tracking* and *charging*. The `smartWatch` module would encompass all of these behaviors, but you may also have some other modules such as `analogueWatch`, `digitalWatch`, `mobilePhone` and `fitnessBand` so the **watch** and **smart device** behaviors would need to be reusable across all of these modules. This is where prototypes are useful. Prototypes allow your modules to inherit properties or functions. Plug.js allows your modules to inherit the properties or functions of any number of prototypes automatically.\r\n\r\nThe smart watch example described above is available as a demo app in the examples folder of this repository.\r\n\r\n\r\n## Factories\r\nA Plug.js factory allow you to customize how your modules get resolved. As outlined above Plug.js provides two factories: singleton and transient. Your custom factory must expose a method called **getInstance**. The **getInstance** method takes three arguments: *moduleConstructor*, *args* and *scope*. See below on how the arguments are used to manage module lifecycle.\r\n\r\n`plug.factory(\"factoryName\", factoryConstructor)`\r\n\r\n| Argument | Type | Example | Required |\r\n| -------- | ---- | ------- | -------: |\r\n| factoryName | String | `\"customResolver\"` | true |\r\n| factoryConstructor | Function | `function () { ... }` | true |\r\n\r\n\r\n`function getInstance(moduleConstructor, args) { ... }`\r\n\r\n| Argument | Type | Required |\r\n| -------- | ---- | -------: |\r\n| moduleConstructor | Function | true |\r\n| args | Array | true |\r\n\r\n\r\n```javascript\r\nplug.factory(\"customResolver\", function() {\r\n\r\n    /* The following is an excerpt from the Plug.js singleton factory source code */\r\n\r\n    /* A variable to store an instance of the module */\r\n    var instance;\r\n\r\n     /* Implement the required getInstance method */\r\n    function getInstance (moduleConstructor, args) {\r\n\r\n        if (!instance) {\r\n            instance = moduleConstructor.apply(null, args);\r\n        }\r\n\r\n        return instance;\r\n    }\r\n\r\n    /* Expose public methods */\r\n    return {\r\n        getInstance: getInstance\r\n    };\r\n\r\n});\r\n\r\nplug.customResolver(\"module1\", [ function() {\r\n    /* ... */\r\n} ]);\r\n```\r\n\r\n## Browser Compatibility\r\n\r\n| Browser | Version |\r\n| -------- | ---- | ------- | -------: |\r\n| Google Chrome | 7+ |\r\n| Mozilla Firefox | 4+ |\r\n| Opera | 11.6+ |\r\n| Internet Explorer | 9+ |\r\n| Apple Safari | 5.1+ |\r\n","google":"UA-59842502-2","note":"Don't delete this file! It's used internally to help with page regeneration."}